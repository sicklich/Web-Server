# Cpp-Web-Server

## 一、项目说明

### 1.1 项目描述
本项目在 `Linux` 系统下实现了 `C++` 版本的**基于事件循环模型的多线程 `Web` 服务器**，可接收 `GET`、`POST`、`HEAD` 请求。

### 1.2 应用技术
`Linux`、`C++`、`Tcp`、套接字编程(`Socket`)、`I/O`多路复用(`Epoll` + `Poll` + `Select`)、线程池、反应堆模型

### 1.3 项目特点
- **底层分别实现 `Epoll + LT`、`Poll`、`Select` 三种模式的 `I/O` 复用模型**，可以通过在初始化 `EventLoop` 对象时，给定不同的 `Dispatcher` 对象来切换；
- **采用主从反应堆模型**，主反应堆模型只负责监听并建立新连接，将新连接分配给从反应堆模型，不涉及业务处理采用单线程处理。从反应堆模型运行在独立的线程中，可以并行处理分配给自己的事件，从而提高并发性能；
- **采用 `One loop per thread` 并发编程模式，并通过线程池进行管理**，可以有效减轻频繁创建/销毁线程带来的性能影响；
- **拥有大量的回调函数**，可以减少代码复用，使代码看起来更加精简，且更具灵活性和扩展性
- **通过强类型枚举作为各类事件的通知描述符**，方便更高效的派发事件，也可以通过位运算判断某一事件是否为组合事件，同时避免了隐式类型转换。

## 二、项目配置
### 2.1 环境及软件版本
- **操作系统**: `Ubuntu 22.04.1 LTS`
- **cmake**: `3.22.1`
- **gcc**: `11.3.0`
- **gdb**: `12.1`

### 2.2 启动方法
1. `Visual Studio`
如果是通过 `Visual Studio` 需要设置库依赖项，然后将头文件和源文件放在一个项目中，运行即可
![库依赖项](images/image1.png)

2. `bash`
- 构建项目: ```bash build.sh```
- 运行项目: ```bash run.sh```

## 三、总结

### 3.1 主要工作
1、实现 `get/post/head` 三种请求解析
2、采用主从反应堆模型，将与客户端的连接和业务处理分割，以提升并发性能；
3、采用 `One loop per thread` 模式，并利用线程池进行统一管理，在提升并行效率的前提下减少了线程创建与销毁的开销；
4、利用回调函数的优势，减少代码复用，增加灵活性及可读性；
5、利用强类型枚举区分不同事件，可以通过位运算一次传递多个不同事件的同时提高代码的安全性。

### 3.2 个人收获
1、对 `HTTP` 的服务过程有了更清晰的认识；
2、对 `TCP` 协议下的 `I/O` 多路复用的实现有了一定的理解；
3、了解了主从反应堆模型以及 `One loop per thread` 模式设计的思路；
4、学会了运用回调函数进行编程的方法。

### 3.3 遇到的问题
1. 两个类相互调用<br>
**问题描述**: 假设 A 类存在成员变量 B 类成员，且 B 类存在成员变量 A 类成员，此时编译器会产生“未定义的符号”的错误提示。<br>
**问题分析**: 上述情况会产生循环依赖，编译器无法解决这个依赖关系，因为编译器在定义数据时需要知道数据的剧情大小，此时两者相互包含，编译器无法准确知道数据的大小，因此会报错。<br>
**解决方案**: 可以使用**前向声明**，但是需要注意的是前向声明只适用于引用、指针等操作，如果只是使用指针，则无需引用头文件且在使用前必须初始化指向一个存在的对象，但是如果需要使用包含类的对象则必须要添加头文件。<br><br>

2. `Broken Pipe`<br>
**问题描述**: 频繁进行大文件访问的时候，有概率会断开连接，产生 `Broken Pipe` 异常。<br>
**问题分析**: `TCP` 通信，在 `C++` 中是通过 `send` 函数发送数据。如果客户端和服务器端一直保持连接，则不会产生问题，但是当服务器和客户端之间的连接断开后（这里是客户端断开连接，可能是宕机或者被 `Kill`），服务器还给客户端发送数据的话，`Linux` 内核会检测到这个错误并向程序发送 `SIGPIPE` 信号，就会产生 `Broken Pipe` 异常。这个错误是由 `TCP` 底层导致的，即使程序逻辑上是在发送完数据后才断开连接。<br>
**解决方案**: 在 `send` 函数的最后一个参数设置为 `MSG_NOSIGNAL`，表示程序忽略 `Linux` 的 `SIGPIPE` 信号，从而不被中断。<br><br>

3. 含中文(特殊符号)文件<br>
**问题描述**: 访问含中文或者特殊符号文件时会提示 404 错误。<br>
**问题分析**: `HTTP GET` 请求的请求行不支持特殊字符，如果有特殊字符就会自动进行转换成 `UTF-8`（三个字符），如将“国”字转换为 `%EF%9B%BD`，此时服务器接收到的数据就不是原本的信息，因此无法找到相应的文件。<br>
**解决方案**: 进行解码，将 `UTF-8` 对应的三个字符转换成一个特殊字符，从而让服务器了解到客户端真正访问的文件，具体的函数实现可以在网上查询。<br><br>

4. `POST` 请求体结尾不含 `\r\n`<br>
**问题描述**: 在解析 `POST` 方式请求体时，发现无法通过 `\r\n` 来获取请求体结束的位置。<br>
**问题分析**: 首先，`HTTP` 协议并没有规定请求体（响应体）要以 `\r\n` 作为结束符；其次，响应体（请求体）的内容是多种多样的，当数据内容包含 `\r\n` 时，解析出来的响应体就是不完整的。<br>
**解决方案**: 大部分 `POST` 请求，会在请求头处添加 `Content-Length`，可以根据 `Content-Length` 来获取 `POST` 的请求体，并根据格式 `xxx=yyy&xxx=yyy` 进行拆分。<br>
**注意**: 并不是所有 `POST` 都会在请求数据时添加 `Content-Length`，如 `chunked` 编码，即`分块传输编码`.尤其是当不知道数据大小的时候，当使用 `chunked` 编码时需要在请求头添加 `Transfer-Encoding: chunked` 字段，否则 `HTTP/1.1` 规范都会要求 `POST` 请求的消息体必须包含 `Content-Length` 字段。<br><br>


### 3.4 部分知识点
1. 与多进程和多线程技术相比，`I/O` 多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，将监视事件的事情交由内核处理，从而大大减小了系统的开销。
2. `select` 是跨平台的，`epoll` 和 `poll` 只能在 `Linux` 平台下使用；`epoll` 底层实现是红黑树，`select` 和 `poll` 底层实现是线性表；`epoll` 和 `poll` 没有最大文件描述符数量限制，`select` 是 `1024`。
3. `Epoll` 有 `EPOLLLT` 和 `EPOLLET` 两种触发模式，LT是默认的模式，ET是“高速”模式。
   - `LT`（水平触发）模式下，只要这个文件描述符还有数据可读，每次调用 `epoll_wait` 都会返回它的事件，提醒用户程序去操作；
   - `ET`（边缘触发）模式下，在它检测到有 `I/O` 事件时，通过 `epoll_wait` 调用会得到有事件通知的文件描述符，对于每一个被通知的文件描述符，如可读，则必须将该文件描述符一直读到空，让 `errno` 返回 `EAGAIN` 为止，否则下次的 `epoll_wait` 不会返回余下的数据，会丢掉事件。如果 `ET` 模式不是非阻塞的，那这个一直读或一直写势必会在最后一次阻塞。
4. 主从反应堆模型是一种网络编程模型，该模型包括一个主线程和多个工作线程。主线程负责监听网络事件，当主线程检测到有网络事件时，会将相应的事件分发给其中一个工作线程处理，从而实现并发处理多个网络连接。主从反应堆模型的优点在于它可以充分利用多核 `CPU` 的优势，同时又可以避免线程切换的开销。此外，由于主线程只负责监听网络事件，工作线程负责实际的网络 `I/O` 和业务处理，因此也避免了多个线程之间的竞争问题。
5. 在 `One loop per thread` 模式中，每个线程都有自己的事件循环`event loop`，当有事件发生时，事件循环会立即返回，并通过回调函数或其他方式通知应用程序处理该事件，线程通过监听不同的事件来处理不同的任务，可以处理多个任务并发执行。这种模式可以避免共享状态的复杂性，但需要注意线程间的同步和协调。

## 四、项目文件目录结构
```
├── build.sh
├── CMakeLists.txt
├── images
│   └── image1.png
├── include
│   ├── Base
│   │   ├── Buffer.h
│   │   ├── ThreadPool.h
│   │   └── WokerThread.h
│   ├── Dispatcher
│   │   ├── Dispatcher.h
│   │   ├── EpollDispatcher.h
│   │   ├── PollDispatcher.h
│   │   └── SelectDispatcher.h
│   ├── HTTP
│   │   ├── HttpRequest.h
│   │   └── HttpResponse.h
│   ├── Log
│   │   └── Log.h
│   └── Net
│       ├── Channel.h
│       ├── EventLoop.h
│       ├── TcpConnection.h
│       └── TcpServer.h
├── LICENSE
├── README.md
├── run.sh
└── src
    ├── Base
    │   ├── Buffer.cpp
    │   ├── ThreadPool.cpp
    │   └── WokerThread.cpp
    ├── CMakeLists.txt
    ├── Dispatcher
    │   ├── Dispatcher.cpp
    │   ├── EpollDispatcher.cpp
    │   ├── PollDispatcher.cpp
    │   └── SelectDispatcher.cpp
    ├── HTTP
    │   ├── HttpRequest.cpp
    │   └── HttpResponse.cpp
    ├── main.cpp
    └── Net
        ├── Channel.cpp
        ├── EventLoop.cpp
        ├── TcpConnection.cpp
        └── TcpServer.cpp
```